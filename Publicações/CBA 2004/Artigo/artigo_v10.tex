\documentclass[conference,harvard,brazil,english]{sbatex}
\usepackage[latin1]{inputenc}
\usepackage{amssymb,amsmath,graphicx,float,ae}

\newcommand\real{\mathbb{R}}
\newcommand{\req}[1]{(\ref{#1})}

%---------------------------------------------------------
\begin{document}

\title{Estimação e controle da posição de um robô móvel utilizando filtro de Kalman descentralizado}

\author{Felipe Kühne}{kuhne@eletro.ufrgs.br}
\address{Universidade Federal do Rio Grande do Sul\\Departamento de Engenharia Elétrica\\Av. Oswaldo Aranha, 103 -- CEP 90035-190\\Porto Alegre, RS, Brasil}

\author[1]{Carlos A. H. Claro}{caclaro@eletro.ufrgs.br}
\author[1]{Sérgio R. Suess}{suess@eletro.ufrgs.br}
\author[1]{Walter F. Lages}{fetter@eletro.ufrgs.br}

\twocolumn[
\maketitle
\selectlanguage{english}

%---------------------------------------------------------
\begin{abstract}
	This paper proposes a full-connected, decentralized control architecture for a wheeled mobile robot. Three different types of sensors are used. The system is distributed in four nodes, in a way that the controller and the sensors are totally independent from each other, giving the architecture the capability to handle individual sensors' failures. An extended Kalman filter (EKF) is used for state estimation and data fusion. The trajectory tracking problem is solved through a feedback linearization and a linear control law for the robot's position. Simulation results are shown for two different trajectories.
\end{abstract}
\keywords{Mobile robots, Kalman filtering, linearizing feedback control, decentralized control.}

\selectlanguage{brazil}

%---------------------------------------------------------
\begin{abstract} 
	Este artigo propõe uma arquitetura descentralizada totalmente conectada para o controle de um robô móvel dotado de rodas. Três tipos diferentes de sensores são utilizados. O sistema é distribuído em quatro nodos, de forma que o controlador e os sensores são totalmente independentes, conferindo ao sistema tolerância a falhas individuais dos sensores. Um filtro de Kalman extendido (EKF) é utilizado para a estimação dos estados e fusão de dados. O problema de rastreamento de trajetória é resolvido através de uma realimentação linearizante e de uma lei de controle linear para a posição do robô. Resultados de simulação são mostrados para dois tipos de trajetórias.
\end{abstract}
\keywords{Robôs móveis, filtro de Kalman, controle por realimentação linearizante, controle descentralizado.}
]

\selectlanguage{brazil}

%---------------------------------------------------------
\section{Introdução}\label{sec:intro}
	No problema de navegação e controle de um robô móvel autônomo, uma das principais informações que deve ser obtida é a atual postura (posição e orientação) deste robô com relação a algum sistema de coordenadas global. Para isso, utilizam-se sensores acoplados ao veículo. De uma forma geral, estes sensores podem ser classificados em sensores de medida {\em relativa} ou {\em absoluta}. 

	No caso de robôs com rodas, é comum o uso de encoders incrementais acoplados aos eixos de rotação das rodas, na técnica denominada {\em odometria} \cite{borenstein1}. Encoders incrementais são bastante utilizados pois são baratos e de fácil implementação. Entretanto, a idéia básica da odometria é a integração da informação da movimentação em um dado período de tempo, o que inevitavelmente leva ao acúmulo ilimitado de erros \cite{kang1,park1}. Para limitar estes erros, faz-se uso de sensores de medida absoluta e com domínios de informação sobrepostos, como aparelhos de GPS e bússolas eletrônicas \cite{medromi1,franz1}. A vantagem de sensores de medida absoluta é que os mesmos não sofrem do problema de integração do erro, visto que, em sensores de medida relativa, o erro é polarizado e integrado no tempo. Por outro lado, a informação proveniente destes sensores também pode ser deturpada, seja, por exemplo, por causa de condições atmosféricas adversas (no caso de aparelhos de GPS) ou por distorções no campo magnético terrestre (no caso de bússolas). No entanto, em geral, estes erros são absolutos e não são integrados.

	Neste trabalho, são utilizados três tipos de sensores, com diferentes tecnologias e com domínios de informação sobrepostos, em uma rede de nodos totalmente conectados. Esta sobreposição dos domínios confere ao sistema a capacidade de {\em graceful degradation}, ou seja, a falha de um sensor não significa a falha de todo o sistema, pois os outros sensores podem ser utilizados para medir a informação do sensor em falha \cite{yajnik1,mutambara1}.

	Para que uma arquitetura descentralizada possa ser vantajosa, é essencial que a informação dos diversos sensores seja combinada de forma a obter-se uma descrição completa, confiável e coerente do sistema. Em um sistema descentralizado, a fusão dos dados ocorre em cada nodo com base na observação local e na informação transmitida pelos outros nodos. Assim, levando em consideração a sobreposição dos domínios de informação dos sensores e realizando a fusão de dados, é possível reduzir a incerteza inerente a cada sensor, possibilitando a obtenção de estimativas mais precisas do que as leituras individuais dos sensores \cite{sjur1}.

	Sendo assim, neste trabalho utilizou-se o filtro de Kalman para a estimação dos estados (obtenção da estimativa {\em local}, correspondente apenas à informação de um determinado nodo) e para fusão de dados (obtenção da estimativa {\em global} dos estados a partir de informações locais).

	Três sensores estão presentes no sistema: encoder, GPS e bússola. Apresenta-se uma estrutura descentralizada totalmente conectada composta de um nodo controlador e três nodos sensores, para um robô móvel dotado de rodas com acionamento diferencial. O problema de rastreamento de trajetória é resolvido por meio de uma realimentação linearizante entrada-saída para a posição do robô. Os sensores e o controlador são implementados de forma totalmente independente, sendo a comunicação entre os nodos feita por meio de {\em sockets}. Os algoritmos foram implementados em linguagem de programação C++ e executados em computadores com sistema operacional Linux.


%---------------------------------------------------------
\section{Modelo cinemático do robô}\label{sec:model}
	Um robô constituído de um corpo rígido e rodas não deformáveis é considerado (Figura~\ref{fig:robo}). A movimentação realiza-se em um plano horizontal. Define-se um sistema de coordenadas global, $\{O,X_o,Y_o\}$, e um sistema de coordenadas móvel, $\{C,X_c,Y_c\}$, associado ao ponto $C$. A cinemática do robô com relação a $C$ é dada por:
% Um robô constituído de um corpo rígido e rodas não deformáveis é considerado (Figura~\ref{fig:robo}). Assume-se que o veículo move-se em um plano e que as rodas não derrapam, ou seja, a velocidade no ponto de contato entre a roda e o solo é nula. A cinemática do robô móvel é descrita por:	
\begin{equation}\label{eqn:model}
	\begin{bmatrix}
		\dot x_c \\ \dot y_c \\ \dot\theta
	\end{bmatrix} =
	\begin{bmatrix}
		\cos\theta & 0 \\
		\sin\theta & 0 \\
		0		   & 1
	\end{bmatrix}
	\begin{bmatrix}
		u_1 \\ u_2
	\end{bmatrix},
\end{equation}
onde $u_1$ é a velocidade tangencial e $u_2$ é a velocidade angular. 
\begin{figure}[H]
	\centering
    \includegraphics[width=.92\linewidth]{Figuras/robo.eps}
    \caption{Modelo geométrico do robô móvel.}
    \label{fig:robo}
\end{figure}

	Ainda, elege-se um ponto, {\em a priori} arbitrário, da estrutura do robô como ponto de referência, dado pelo sistema de coordenadas $\{R,X_r,Y_r\}$ \cite{lages2}. A posição deste ponto com relação ao sistema global é a saída ${\bf y}_s({\bf x})$, dada por:
\begin{equation}\label{eqn:ys}
		{\bf y}_s({\bf x}) =
			\begin{bmatrix}
					x_r \\
					y_r
			\end{bmatrix} =
			\begin{bmatrix}
				x_c + x^c_r\cos\theta - y^c_r\sin\theta \\
				y_c + x^c_r\sin\theta + y^c_r\cos\theta
			\end{bmatrix} 
\end{equation}


%---------------------------------------------------------
\section{Controle por realimentação linearizante}\label{sec:control}

	Para que se possa aplicar uma realimentação linearizante, é necessário que o modelo \req{eqn:model} seja escrito na forma afim \cite{isidori1}, ou seja,
\begin{equation}\label{eqn:x_cont}
	\dot {\bf x} = f({\bf x}) + \sum^p_{i=1}g_i({\bf x}){\bf u}_i
\end{equation}

	O método de linearização entrada-saída consiste em diferenciar a expressão de saída até que a entrada ${\bf u}({\bf x})$ apareça na expressão \cite{isidori1}. Assim, pode-se escrever:
\begin{equation}\label{eqn:diff_y}
	{\bf y}^{(n)}_s({\bf x}) = \alpha({\bf x}) + \beta({\bf x}){\bf u}({\bf x}),
\end{equation}
que é linearizado aplicando-se o seguinte controle linearizante:
\begin{equation}\label{eqn:u}
	{\bf u}({\bf x}) = \beta({\bf x})^{-1}{\bf v}({\bf x}) - \alpha({\bf x})
\end{equation}

	Para o robô considerado neste trabalho, tem-se que $n=1$, $p=2$, $f({\bf x})=0$ e
\begin{align*}
	g_1({\bf x}) &= \left[ \cos\theta ~~ \sin\theta ~~ 0 \right]^T \\
	g_2({\bf x}) &= \left[ 0 ~~ 0 ~~1  \right]^T,
\end{align*}
logo, $\alpha({\bf x})=0$ e
\begin{equation*}\begin{split} \label{eqn:beta}
	\beta({\bf x}) &=
		\begin{bmatrix}
			\frac{\partial x_r}{\partial {\bf x}}g_1({\bf x}) & \frac{\partial x_r}{\partial {\bf x}}g_2({\bf x}) \\
			\frac{\partial y_r}{\partial {\bf x}}g_1({\bf x}) & \frac{\partial y_r}{\partial {\bf x}}g_2({\bf x})
		\end{bmatrix} \\ &= 
			\begin{bmatrix}
				\cos\theta & -\left( x^c_r\sin\theta + y^c_r\cos\theta \right) \\
				\sin\theta & x^c_r\cos\theta - y^c_r\sin\theta
			\end{bmatrix}
\end{split}\end{equation*}

	Fica evidente aqui a necessidade de definir um ponto $R$ que não esteja sobre o eixo comum às rodas fixas, para que $\beta({\bf x})$ seja não singular. Pontos sobre este eixo (como o ponto $C$) podem mover-se instantaneamente em apenas uma direção, enquanto que os demais pontos do corpo do robô podem mover-se em duas direções \cite{lages1}. 
	
	Utilizando \req{eqn:u} em \req{eqn:diff_y}, pode-se projetar uma lei linear proporcional para o controle do modelo \req{eqn:diff_y} em malha fechada. Assim:
\begin{equation*}
	{\bf v}({\bf x}) = {\bf L}{\bf e}_s,
\end{equation*}
onde ${\bf L}$ é uma matriz de ganhos positivos e ${\mbox{\bf e}_s={\bf y}_{ref}-{\bf y}_s}$. Assim:
\begin{equation*}
	{\bf L} =
		\begin{bmatrix}
			l_x & 0 \\
			0 & l_y
		\end{bmatrix} \quad
	{\bf e}_s =
		\begin{bmatrix}
			x_{ref} - x_r \\
			y_{ref} - y_r		
		\end{bmatrix}
\end{equation*}

	Então, representa-se o sistema em malha fechada pelo diagrama de blocos da Figura \ref{fig:bloco3}.
\begin{figure}
	\centering
    \includegraphics[width=\linewidth]{Figuras/bloco3.eps}
    \caption{Diagrama de blocos do sistema em malha fechada.}
    \label{fig:bloco3}
\end{figure}


%---------------------------------------------------------
\section{Estimação dos estados por filtro de Kalman}\label{sec:ekf}
	O filtro de Kalman \cite{kalman1} é um método linear recursivo para a estimação de dados e muito utilizado em estudos de sistemas dinâmicos, em especial problemas de navegação aeroespacial, robótica e controle \cite{leonard1}. A estimativa feita pelo filtro de Kalman é ótima segundo um critério de mínimo erro médio quadrático, ou seja, no sentido de que o mesmo minimiza a covariância do erro da estimativa.

	Considerando que o encoder fornece informação de posição e orientação, o GPS fornece informação de posição e a bússola fornece informação de orientação, define-se a expressão de observação como sendo:
\begin{multline*}
		{\bf y}(k) = [ x_{enc}(k)~~y_{enc}(k)~~x_{gps}(k)~~y_{gps}(k) \\
			\theta_{enc}(k)~~\theta_{bus}(k) ]^T
\end{multline*}

	Assim, assumindo a existência de ruídos aditivos no modelo e na observação, pode-se reescrever o modelo \req{eqn:x_cont} na forma discreta como:
\begin{align}
		{\bf x}(k+1) &= f({\bf x}(k)){\bf u}(k) + {\bf w}(k)\label{eqn:x_discrete} \\
		{\bf y}(k)   &= h({\bf x}(k)) + {\bf v}(k)\label{eqn:y_discrete},
\end{align}
com ${\bf x}(k)=[x_1(k)~~x_2(k)~~x_3(k)]^T$ e
\begin{align*}
	f({\bf x}(k)) &=
		\begin{bmatrix}
			x_1(k) + \cos x_3(k)T & 0 \\
			x_2(k) + \sin x_3(k)T & 0 \\
			0                       & x_3(k)T
		\end{bmatrix},
\end{align*}
onde $T$ é o período de amostragem e $k$ é o instante de amostragem. ${\bf w}(k)$ e ${\bf v}(k)$ são vetores de ruído branco (com distribuição normal e média zero) de processo e de medida, respectivamente, dados pelas seguintes expressões de covariância: 
\begin{align}
	E\left\{{\bf w}(k){\bf w}^T(i)\right\} &= {\bf Q}(k)\delta(k-i)\label{eqn:Q} \\
	E\left\{{\bf v}(k){\bf v}^T(i)\right\} &= {\bf R}(k)\delta(k-i)\label{eqn:R} \\
	E\left\{{\bf w}(k){\bf v}^T(i)\right\} &= 0\label{eqn:wv},
\end{align}
\noindent$E\{\cdot\}$ é o operador valor esperado e ${\bf Q}(k)$ e ${\bf R}(k)$ são matrizes diagonais formadas pelas variâncias de ${\bf w}(k)$ e ${\bf v}(k)$, respectivamente.


%---------------------------------------------------------
\subsection{Filtro de Kalman para sistemas lineares}
	Conforme \citeasnoun{goodwin1}, as expressões recursivas para a utilização do filtro de Kalman para sistemas lineares são as seguintes:
\begin{align*}
	{\bf K}(k) &= {\bf P}(k|k-1){\bf C}^T(k) \\
		&\bigl({\bf C}(k){\bf P}(k|k-1){\bf C}^T(k) + {\bf R}(k) \bigr)^{-1} \\
	\hat {\bf x}(k|k) &= \hat{\bf x}(k|k-1) + \\
		&+{\bf K}(k)\bigl({\bf y}(k) - {\bf C}(k)\hat {\bf x}(k|k-1) \bigr) \\
	{\bf P}(k|k) &= \bigl( {\bf I} - {\bf K}(k){\bf C}(k) \bigr) {\bf P}(k|k-1) \\
	\hat {\bf x}(k+1|k) &= {\bf A}(k)\hat {\bf x}(k|k)+{\bf B}(k){\bf u}(k) \\
	{\bf P}(k+1|k) &= {\bf A}(k){\bf P}(k|k){\bf A}^T(k)+{\bf Q}(k),
\end{align*}
onde ${\bf K}(k)$ é o ganho do filtro de Kalman, ${\bf P}(k|k)$ é a covariância do erro de estimação e ${\bf A}(k)$, ${\bf B}(k)$ e ${\bf C}(k)$ são matrizes que descrevem o modelo linear ${\mbox{\bf x}(k+1)= {\bf A}(k){\bf x}(k)}+{\bf B}(k){\bf u}(k)$, \mbox{${\bf y}(k)={\bf C}(k){\bf x}(k)$}.


%---------------------------------------------------------
\subsection{Extensão do filtro de Kalman para sistemas não lineares}
	Um dos requisitos para a utilização do filtro de Kalman é que o sistema seja linear. Como este não é o caso, algum tipo de linearização precisa ser usada \cite{mutambara1}. Assim, seja a estimativa do estado dada por:
\begin{equation*}
	\hat {\bf x}(k|k) = E \left\{ {\bf x}(k) \right\}
\end{equation*}

	Expandindo o modelo \req{eqn:x_discrete}--\req{eqn:y_discrete} em série de Taylor em torno desta estimativa e desprezando-se os termos de ordem superior, tem-se:
\begin{multline*}
	{\bf x}(k+1) \approx f(\hat {\bf x}(k|k)){\bf u}(k) + \\ + {\bf F}(k)\bigl({\bf x}(k)-\hat {\bf x}(k|k)\bigr) + {\bf w}(k) \\
	{\bf y}(k)   \approx h(\hat {\bf x}(k|k)) + {\bf H}(k)\bigl({\bf x}(k)-\hat {\bf x}(k|k)\bigr) + {\bf v}(k),
\end{multline*}
onde ${\bf F}(k)$ e ${\bf H}(k)$ são os jacobianos de $f({\bf x}(k))$ e $h({\bf x}(k))$, respectivamente, avaliados em $\hat {\bf x}(k|k)$,
\begin{equation*}
	F(k) = \left.\frac{\partial f({\bf x})}{\partial {\bf x}}\right|_{{\bf x}=\hat {\bf x}(k|k)} \quad
	H(k) = \left.\frac{\partial h({\bf x})}{\partial {\bf x}}\right|_{{\bf x}=\hat {\bf x}(k|k)}
\end{equation*} 

	Assim, após algumas manipulações matemáticas, chega-se às expressões do filtro de Kalman extendido:
%\begin{multline}\label{eqn:K_nlin}
%	{\bf K}(k) = {\bf P}(k|k-1){\bf H}^T(k) \\
%		\bigl( {\bf H}(k){\bf P}(k|k-1){\bf H}^T(k) + {\bf R}(k) \bigr)^{-1}
%\end{multline}
%\begin{align}		
%	{\bf P}(k|k) = \bigl( {\bf I} - {\bf K}(k){\bf H}(k) \bigr) {\bf P}(k|k-1) \\
%	\hat {\bf x}(k|k) = \hat{\bf x}(k|k-1)+{\bf K}(k)\bigl( {\bf y}(k)-{\bf H}(k)\hat{\bf x}(k|k-1)\bigr) \\
%	\hat {\bf x}(k+1|k) = f(\hat {\bf x}(k|k)){\bf u}(k)\label{eqn:xk1k_nlin} \\
%	{\bf P}(k+1|k) = {\bf F}(k){\bf P}(k|k){\bf F}^T(k) + {\bf Q}(k)\label{eqn:Pk1k_nlin}
%\end{align}
\begin{align}
	{\bf K}(k) &= {\bf P}(k|k-1){\bf H}^T(k)\notag \\
		\bigl({\bf H}&(k){\bf P}(k|k-1){\bf H}^T(k) + {\bf R}(k) \bigr)^{-1}\label{eqn:K_nlin} \\
	\hat {\bf x}(k|k) &= \hat{\bf x}(k|k-1)+\notag \\
		&+{\bf K}(k)\bigl({\bf y}(k)-{\bf H}(k)\hat{\bf x}(k|k-1)\bigr)\notag \\
	{\bf P}(k|k) &= \bigl( {\bf I} - {\bf K}(k){\bf H}(k) \bigr) {\bf P}(k|k-1)\notag \\
	\hat {\bf x}(k+1|k) &= f(\hat {\bf x}(k|k)){\bf u}(k)\label{eqn:xk1k_nlin} \\
	{\bf P}(k+1|k) &= {\bf F}(k){\bf P}(k|k){\bf F}^T(k) + {\bf Q}(k)\label{eqn:Pk1k_nlin}
\end{align}

	Tem-se portanto um método para obter o estado estimado $\hat {\bf x}(k|k)$ a partir de $\hat {\bf x}(k|k-1)$, ${\bf P}(k|k-1)$ e da medida ${\bf y}(k)$, para um sistema não linear como o considerado nas equações \req{eqn:x_discrete}--\req{eqn:y_discrete}.

	Pode ainda ser utilizado aqui o {\em Princípio da Equivalência à Certeza Presumida} \cite{goodwin1}. Então, utiliza-se o controle linearizante projetado na Seção \ref{sec:control} para o modelo \req{eqn:x_discrete}--\req{eqn:y_discrete}, considerando agora que a leitura dos estados são fornecidas através do filtro de Kalman extendido. 

	Na Figura \ref{fig:bloco1}, tem-se o diagrama de blocos do sistema completo.
\begin{figure}[H]
	\centering
    \includegraphics[width=\linewidth]{Figuras/bloco1.eps}
    \caption{Diagrama de blocos do sistema em malha fechada.}
    \label{fig:bloco1}
\end{figure}


%---------------------------------------------------------
\subsection{Filtro de Kalman extendido descentralizado}
	O emprego de uma estrutura descentralizada em uma rede de nodos totalmente conectados, como a utilizada neste trabalho, faz com que a estimativa global do estado, computada em cada um dos nodos, seja idêntica à estimativa que seria computada em um sistema centralizado. Ainda, como dito anteriormente, esta estrutura de estimação deixa o sistema tolerante a falhas individuais dos sensores. Assim, se um dos nodos ou a comunicação falhar, os outros nodos e o controlador continuarão a realizar a fusão dos dados e a calcular a estimativa global dos estados \cite{mutambara1}.

	Por conveniência, escreve-se o vetor de ruídos ${\bf v}(k)$ como:
\begin{equation*}
		{\bf v}(k) = [ {\bf v}_{enc}^T(k) ~~ {\bf v}_{gps}^T(k) ~~ {\bf v}_{bus}(k) ]^T
\end{equation*}

	Para o caso onde é feita a estimação descentralizada totalmente conectada, apenas a expressão de observação precisa ser particionada para cada nodo. Neste caso, se todas as inicializações forem iguais, todos os nodos irão gerar estimativas globais idênticas dos estados. Entretanto, é necessário executar o algoritmo do filtro de Kalman extendido em cada um dos nodos, a fim de se calcular todos os parâmetros necessários para, a partir da estimativa local, realizar a fusão e calcular a estimativa global. Assim, como cada nodo sensor possui um domínio de informação diferente, tem-se que:
\begin{align}
	{\bf y}_{enc}(k) &=
		\begin{bmatrix}
			x_{enc}(k) \\
			y_{enc}(k) \\
			\theta_{enc}(k)
		\end{bmatrix} + {\bf v}_{enc}(k)\label{eqn:y_enc} \\ 
	{\bf y}_{gps}(k) &=
		\begin{bmatrix}
			x_{gps}(k) \\
			y_{gps}(k)
		\end{bmatrix} + {\bf v}_{gps}(k)\label{eqn:y_gps} \\ 
	{\bf y}_{bus}(k) &=
		\theta_{bus}(k) + {\bf v}_{bus}(k)\label{eqn:y_bus}
\end{align}

	O sistema de acionamento do robô também possui um processador dedicado, de forma que pode ser encarado como um nodo do sistema que possui apenas atuadores e nenhum sensor. Como este nodo aciona as interfaces de potência, por questões de segurança optou-se por utilizar componentes bem mais confiáveis do que os utilizados nos nodos sensores. Assim, a implementação do controle neste nodo, de forma centralizada, não apresenta problemas de confiabilidade. Por outro lado, como os nodos sensores possuem uma menor confiabilidade, o cálculo da lei de controle não pode ser baseado na estimativa obtida por qualquer destes nodos. Portanto, o nodo controlador, além de computar a lei de controle, deverá também, antes disto, realizar a fusão das estimativas locais transmitidas pelos sensores. Esta fusão é feita também através do mesmo algoritmo do filtro de Kalman implementado nos outros nodos.

	Na Figura~\ref{fig:bloco2}, é mostrada a organização dos nodos e suas funções, bem como o fluxo de dados entre eles. Nos nodos sensores, as setas contínua, traço-ponto e tracejada significam, respectivamente, a transmissão de dados do encoder, do GPS e da bússola. Nota-se que no nodo controlador não existem sensores, e portanto, nem a operação de estimação, apenas a de fusão dos dados. 
\begin{figure}[htbp]
	\centering
    \includegraphics[width=\linewidth]{Figuras/bloco2.eps}
    \caption{Organização dos nodos e o fluxo de dados.}
    \label{fig:bloco2}
\end{figure}

	\citeasnoun{mutambara1}~mostra que não é possível descentralizar o filtro de Kalman convencional, já que as inovações entre os diversos sensores são correlacionadas. Entretanto, uma forma algebricamente equivalente ao filtro de Kalman é o filtro de Informação. Assumindo que a matriz ${\bf R}(k)$ é bloco-diagonal, é possivel particionar os estados de informação de forma que a estimativa global seja a soma de todas as inovações locais. Assim, 
\begin{align*}
	\hat{\bf z}(k|k)=\hat{\bf z}(k|k-1)+\sum_{i=1}^{N}\biggl(\tilde{\bf z}_i(k|k)-\hat{\bf z}(k|k-1)\biggr) \\
	{\bf Z}(k|k)={\bf Z}(k|k-1)+\sum_{i=1}^{N}\biggl(\tilde{\bf Z}_i(k|k)-{\bf Z}(k|k-1)\biggr)	
\end{align*}
onde $N$ é o número de nodos sensores e o sobrescrito $\tilde{\phantom z}$ significa medidas locais de cada nodo $i$, enquanto que $\hat{\phantom z}$ significa medidas globais. ${\bf z}$ e ${\bf Z}$ são, respectivamente, o estado e a matriz de informação, que se relacionam com o filtro de Kalman por ${\bf z}={\bf P}^{-1}{\bf x}$ e ${\bf Z}={\bf P}^{-1}$. Assim, pode-se chegar às expressões utilizadas no filtro de Kalman descentralizado:
\begin{align}
	\hat {\bf x}(k|k) &= {\bf P}(k|k) \biggl({\bf P}^{-1}\hat {\bf x}(k|k-1) + \sum_{i=1}^{N}{\bf e}_i(k)\biggr)\label{eqn:xglobal} \\
	{\bf P}(k|k) &= \biggl( {\bf P}^{-1}(k|k-1) + \sum_{i=1}^{N}{\bf E}_i(k)\biggr)\label{eqn:Pglobal}
\end{align}
onde ${\bf e}_i(k)$ e ${\bf E}_i(k)$ são, respectivamente, as {\em informações de erro} de estado e de variância de cada nodo $i$, dadas por:
\begin{align}
	{\bf e}_i(k)&=\tilde{\bf P}_i^{-1}(k|k)\tilde{\bf x}_i(k|k) - {\bf P}^{-1}(k|k-1)\hat{\bf x}(k|k-1)\label{eqn:ei} \\
	{\bf E}_i(k)&=\tilde{\bf P}_i^{-1}(k|k) - {\bf P}^{-1}(k|k-1)\label{eqn:Ei}
\end{align}

	Levando em conta todas as considerações citadas acima, o filtro de Kalman extendido descentralizado, em cada nodo, foi implementado da seguinte maneira:

	{\bf 1.} Obedecendo ao critério de minimização do erro médio quadrático, calcula-se o ganho do filtro de Kalman - expressão~\req{eqn:K_nlin}

	{\bf 2.} Calcula-se o estado estimado local:
\begin{equation*}
	\tilde {\bf x}(k|k) = \hat {\bf x}(k|k-1) + {\bf K}(k) \left( {\bf y}(k) - h(\hat {\bf x}(k|k-1)) \right)
\end{equation*}

	{\bf 3.} Calcula-se a covariância local:
\begin{equation*}
	\tilde {\bf P}(k|k) = \left( {\bf I} - {\bf K}(k){\bf H}(k) \right) {\bf P}(k|k-1)
\end{equation*}

	{\bf 4.} Calcula-se a informação de erro de estado~- expressão~\req{eqn:ei}
	
	{\bf 5.} Calcula-se a informação de erro de variância - expressão~\req{eqn:Ei}

	Neste ponto, as grandezas ${\bf E}(k)$ e ${\bf e}(k)$ de cada nodo são tansmitidos para os outros nodos através de {\em sockets}. Faz-se agora a fusão destes dados, conforme os passos a seguir:

	{\bf 6.} Calcula-se a estimativa global - expressão~\req{eqn:xglobal}
	
	{\bf 7.} Calcula-se a covariância global - expressão~\req{eqn:Pglobal}

	{\bf 8.} Calcula-se a predição da estimativa global~- expressão \req{eqn:xk1k_nlin}

	{\bf 9.} Calcula-se a predição da covariância global~- expressão \req{eqn:Pk1k_nlin}

	E assim repetem-se os passos 1 a 9, até o fim da trajetória. 

	Os passos 6 a 9 são referentes à operação de fusão de dados. Como o controlador não realiza operações de observação ou de estimação, apenas estes passos são necessários para este nodo, considerando que o mesmo também recebe as grandezas ${\bf e}(k)$ e ${\bf E}(k)$ dos nodos sensores.


%---------------------------------------------------------
\section{Resultados de simulação}\label{sec:sim}
	São mostrados agora os resultados de simulação para duas trajetórias: uma em forma de oito e outra em forma de quadrado. Em todas as figuras, a linha tracejada representa a trajetória de referência.

	Nas Figuras \ref{fig:oitoctrl} e \ref{fig:quadctrl} pode-se ver a ação do controle sobre o comportamento do robô. Nota-se que a posição controlada converge para a trajetória de referência.
\begin{figure}[htbp]
	\centering
    \includegraphics[width=.88\linewidth]{Figuras/oitoctrl.eps}
    \caption{Posição controlada para uma trajetória em forma de oito.}
    \label{fig:oitoctrl}
\end{figure}
\begin{figure}[htbp]
	\centering
    \includegraphics[width=.88\linewidth]{Figuras/quadctrl.eps}
    \caption{Posição controlada para uma trajetória em forma de quadrado.}
    \label{fig:quadctrl}
\end{figure}

	Nas Figuras \ref{fig:oito20} e \ref{fig:quad20}, verifica-se o efeito do aumento do ruído de processo no controle. O desvio padrão do ruído de processo foi aumentado em 20 vezes (${\bf Q}=diag[0.0004,0.0004,0.0006]$). Nota-se que o robô ainda segue a trajetória, apesar de fazê-lo de forma mais errática.
\begin{figure}[htbp]
	\centering
    \includegraphics[width=.88\linewidth]{Figuras/oito20.eps}
    \caption{Efeito do aumento do ruído de processo.}
    \label{fig:oito20}
\end{figure}
\begin{figure}
	\centering
    \includegraphics[width=.88\linewidth]{Figuras/quad20.eps}
    \caption{Efeito do aumento do ruído de processo.}
    \label{fig:quad20}
\end{figure}


%---------------------------------------------------------
\section{Conclusões}\label{sec:conc}
	Neste artigo, foi demonstrado o uso de uma estrutura composta de nodos descentralizados e totalmente conectados, para a estimação ótima da configuração e controle da posição de um robô móvel. Três sensores com domínios de informação sobrepostos foram utilizados. 

	Verificou-se as vantagens de se utilizar uma arquitetura descentralizada totalmente conectada. Observou-se o desempenho do filtro de Kalman extendido descentralizado como estimador ótimo de dados, e do controle linearizante, que mostrou desempenhos bem satisfatórios para as diversas situações simuladas.

	Como trabalhos futuros, pretende-se utilizar esta estrutura para o processamento da mesma em tempo real, preparando a implementação real de uma arquitetura descentralizada para controle em tempo real de um robô móvel, e também avaliar o desempenho sobre outras estruturas de comunicação, como CAN, TCP e UDP.

%---------------------------------------------------------
\section*{Agradecimentos}\label{sec:thanks}
	Agradecimento à CAPES pelo apoio financeiro.

%---------------------------------------------------------
\bibliography{bibartigo}

%---------------------------------------------------------
\end{document}
